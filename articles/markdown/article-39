# RenumberRequests rules for renumbering

In this document RenumberRequest objects are called **RR**, and the RenumberRequests container object is called **RRs**. 

Other terminology used in the code:

- The original number of a piece is called ***oldNum***
- The number being assigned as a replacement to oldNum is called ***newNum***
- The piece that is receiving a newNum is called a ***receivier***
- The piece that lost its number in the exchange is call the ***provider***

This means that `provider->oldNum = receiver->newNum`

## Properties used

### Storage and reference properties

- \_heap   
   The heap stores the sorted collection of RR objects. The sorting strategy was (and is) a point of debate. The sum of the old and new number ascending is being used.   
   This probably won't be useful when a symbol system is used for numbering pieces.
- \_indexed\_list   
   This is a second set of references to the RR objects; an array indexed by old-number `[oldNum => RR{ }]
- \_valid\_symbols
   An array of all valid piece numbers `[sym => sym]`

### Calculating properties

There are several tally, usage, and checklist properties that keep track of the evolving renumbering situation. Their role will be described in a later section.
 
- \_bad\_symbols
- \_explicit\_receivers
- \_receiver\_checklist
- \_explicit\_providers  
   In the diagram below this property is represented as `provider`
- \_providers\_checklist


## Rules for renumbering

One detail regarding the actual implementation, Piece entities are not used during the request or validation process. When pieces are mentioned, we will be referring to RR objects. These objects carry all the data user needs to make the request and that we need to validate it.

**Rules**

1. <span id="rule-1">Each involved piece must act as a ***provider*** exactly once </span>
2. <span id="rule-2">Each involved piece must act as a ***receiver*** exactly once.</span>
3. <span id="rule-3">All ***newNum***s must be in the set of valid symbols</span>

<span id="hidden-rule">The hidden implication</span> is that **each involved piece must act both as a provider and a receiver**.

Rule 2 is enforced by the nature of the form. Each piece has one input that might be filled with a new number for that piece. There is no way to assign more than one new number.

On the other hand, a number can entered in many inputs so rule 3 can be accidentally violated.

The property that tracks [explicit provider](#explicit-provider-structure) use has a special structure to allow duplicate use detection.

### Implementing code

The first phase of rules-checking takes place as the RR objects are inserted into RRs. They're passed in one at a time as illustrated below.

![Required user/member record structure](http://g.origamistructures.com/w_img/insertRenumberRequestFlow.png)   

At the end of this process we have a few critical pieces of information.

- All violations of [Rule 3](#rule-3) (bad symbols) are known
   - The bad symbols are store in the property [\_bad\_symbol](#bad-symbol-structure)).  
   In addition, each RR object that received a bad symbol has its `$_bad_new_number` flag set to `TRUE`.
- We know the pieces that explicitly received a new number (property illustrated in [\_explicit\_receiver structure](#explicit-receiver-structure)).
- We know the pieces that are loosing numbers because of explicit reassignment to a new pieces (property illustrated in [\_explicit\_provider structure](#explicit-provider-structure)).
- We know about duplicate use of symbols ([rule 1 violations](#rule-1))
  - Each receiving piece is recorded in the second level of the [\_explicit\_provider](#explicit-provider-structure) as `oldNum => oldNum`.  
   The RR objects that receive copies of the new number also have their `$duplicate_new_number` flag set to `TRUE`.
   
   
#### \_bad\_symbol structure

```php
$_bad_symbols [
   badSym1 => badSym1,
   badSym2 => badSym2,
 ],
```

#### \_explicit\_receiver structure

```php
$_explicit_receiver = [
    oldNum1 => oldNum1,
    oldNum2 => oldNum2,
];
```

#### \_explicit_provider structure

```php
$_explicit_provider = [
    newNum1 => [
        oldNum1 => oldNum1, //a piece receiving newNum1
        oldNum2 => oldNum2, //a duplicate use of newNum
    ],
    newNum2 => [
        oldNum3 => oldNum3, //a piece receiving newNum2
    ],
]; 
```

This leave the [hidden rule](#hidden-rule) to verify.

Consider the simpler request "change #2 to #1". This will give us these two properties which reflect the explicit requests:

```php
$_explicit_receiver = [
   2 => 2
];
$_explicit_provider = [
   1 => [
      2 => 2
   ]
];
```

We now have to account for the implicit requests to fulfill the hidden rule. The provider (#1) must also be a receiver and the receiver (#2) must also be a provider.


