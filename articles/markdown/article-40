# Record ownership after creation of Artist system

## What was build

The initial build of the system organized all records in every table on a `belongsTo('Users')` association.

The thinking was:

- background injection of `user_id` into every query would serve as a layer of security for user data
- we would have a convenient way of isolating all a user's data should there be a TOS issue, subscription cancellation and data migration, or other situation.

The id column was cloned with the idea of eventually changing the value of `artitst_id` to further protect the key `User.id`. But no clear thought was given to which value would act as the universal link.

There was some degree of awareness that users would need to manage other user/artist data, so the `Users.id` column data was cloned to `Users.artist_id`.

A globally available method, `SystemState->artistId( )` was stubbed in to inject the key value in all queries. The plan at this point was to place **act as** and **manage artists** value returns behind this method. As long as this method was called for all where-injection tasks, we'd be able to build a manager system later.

This is how the system stands.

### Initial system capabilities

- Allows user/artist self editing
- Allows manager users to maintain the data of multiple user/aritsts
   - Manager users can also be artists but need not be
- More than one system user can have access to an artist's data
- Every artist must be a registered system user
- Every manager must be a registered system user

### Initial system limitations

The initial system does not allow a manager to create and manage artists freely. Since artists must be registered users, either an individual would have to create an account then extend editing privileges to the manager, or the manager would have to register multiple users on the system and link them to her main account.

## The new Artist system proposal

I'm now exploring a Member based Artist system ([details here](/article/editing-users-and-artists)).

The goal here is make artists and their associated data into portable modules, independent of registered users. 

The one big grey-area is; how does the global record linking work in this system? In theory at least, it's still possible to link everything off the user. The problem is, this is a very broad-brush permission system for artists that also want to have managers.

### The very bad, no good, privacy policy

I wouldn't want to use a system that told me I could let my galleries and sales reps keep my disposition data up to date but that I would have to turn my entire marketing  and contact address book over to them in the bargain.

In truth, this problem exists in the current plan too. It just hadn't come to light yet.

## General permission filters

Principle #1: Granularity increase interface complexity.  

Principle #2: UX Interface complexity reduces feature adoption.  

Principle #3: System logic can reduce UX complexity

Principle #4: System logic complexity increases maintenance problems.

So we're looking for some magic balance here.

- `User.id` could remain the universal link for all data private data. 
- Data is created private by default and must be white-listed to be shared.
- And additional `Artist.id` link could be added to any data that is to be shared with managers.
   - This means an artist could make a limited number of their works available for management too.
   - A global switch to share disposition linked contact data might make sense. But even here, would it be desirable to filter out address data from manager view?
- It feels like managers should not be able to hide disposition linked data from the artist, though the artist might legitimately hide it from the manager.
- Could the **Artist** record be the medium of exchange? 
   - If an artist created a new one with a manager's token in it, the manager would then magically acquire it when they logged on.
   - and the artist could revoke the link at any time
- Group/proxy members that are simply organizing groups would not be meaningful to share. The managers could make their own categories.
   - But groups could help partition share-sets of member records
- a new interface page will be needed for artists to manage what they share with managers.

![Proposed Artist Stack](http://g.origamistructures.com/w_img/ProposedArtistStack.png)   

If the public records are linked to the Artist record, we should be able to expand on the value injection system.

- Based on a user's edit-mode settings, discover which artist/artists they have chosen to include for their session
- Retrieve those Artist records using an updated version of `SystemState->artistId( )`
   - This would be a smaller scale task just for getting these gateway Artist records.
- The artist entities have a key injector method that analyzes the users relationship to the artist record. Based on that link value, the filtered (or full) set of stack data is assembled.
- Artist entity may end up being the gateway filter for constructing other stacks (or all stacks?).

So in this plan, there are two layers of background query-value injectors; the acting-as/managing selector to get the set of artist gateway records, then the detailed query and stack construction processes that are filtered by the link injector found in the Artist entities.

Unless I'm missing something, the whole problem will now be focused on making it easy to manage the process of 'publishing' data on the artist records.


Topics: Studio Manager, Artist, User, Brainstorming